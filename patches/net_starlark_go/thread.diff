diff --git lib/json/json.go lib/json/json.go
index bc67be5..a75e484 100644
--- lib/json/json.go
+++ lib/json/json.go
@@ -201,7 +201,7 @@ func encode(thread *starlark.Thread, b *starlark.Builtin, args starlark.Tuple, k
 			names = append(names, x.AttrNames()...)
 			sort.Strings(names)
 			for i, name := range names {
-				v, err := x.Attr(name)
+				v, err := x.Attr(thread, name)
 				if err != nil {
 					return fmt.Errorf("cannot access attribute %s.%s: %w", x.Type(), name, err)
 				}
@@ -445,7 +445,7 @@ func decode(thread *starlark.Thread, b *starlark.Builtin, args starlark.Tuple, k
 					}
 					i++ // ':'
 					value := parse()
-					dict.SetKey(key, value) // can't fail
+					dict.SetKey(thread, key, value) // can't fail
 					b = next()
 					if b != ',' {
 						if b != '}' {
diff --git lib/proto/proto.go lib/proto/proto.go
index e8b235d..d1bb743 100644
--- lib/proto/proto.go
+++ lib/proto/proto.go
@@ -279,7 +279,7 @@ func setFieldStarlark(thread *starlark.Thread, fn *starlark.Builtin, args starla
 		return nil, fmt.Errorf("%s: %v does not have field %v", fn.Name(), m.desc().FullName(), field)
 	}
 
-	return starlark.None, setField(m.msg, field.Desc, v)
+	return starlark.None, setField(thread, m.msg, field.Desc, v)
 }
 
 // get_field(msg, field) retrieves the value of a field.
@@ -347,12 +347,12 @@ func (d MessageDescriptor) CallInternal(thread *starlark.Thread, args starlark.T
 	}
 
 	// Convert named arguments to field values.
-	err := setFields(dest.msg, kwargs)
+	err := setFields(thread, dest.msg, kwargs)
 	return dest, err
 }
 
 // setFields updates msg as if by msg.name=value for each (name, value) in items.
-func setFields(msg protoreflect.Message, items []starlark.Tuple) error {
+func setFields(thread *starlark.Thread, msg protoreflect.Message, items []starlark.Tuple) error {
 	for _, item := range items {
 		name, ok := starlark.AsString(item[0])
 		if !ok {
@@ -362,7 +362,7 @@ func setFields(msg protoreflect.Message, items []starlark.Tuple) error {
 		if err != nil {
 			return err
 		}
-		if err := setField(msg, fdesc, item[1]); err != nil {
+		if err := setField(thread, msg, fdesc, item[1]); err != nil {
 			return err
 		}
 	}
@@ -371,7 +371,7 @@ func setFields(msg protoreflect.Message, items []starlark.Tuple) error {
 
 // setField validates a Starlark field value, converts it to canonical form,
 // and assigns to the field of msg.  If value is None, the field is unset.
-func setField(msg protoreflect.Message, fdesc protoreflect.FieldDescriptor, value starlark.Value) error {
+func setField(thread *starlark.Thread, msg protoreflect.Message, fdesc protoreflect.FieldDescriptor, value starlark.Value) error {
 	// None unsets a field.
 	if value == starlark.None {
 		msg.Clear(fdesc)
@@ -396,7 +396,7 @@ func setField(msg protoreflect.Message, fdesc protoreflect.FieldDescriptor, valu
 		list.Truncate(0)
 		var x starlark.Value
 		for i := 0; iter.Next(&x); i++ {
-			v, err := toProto(fdesc, x)
+			v, err := toProto(thread, fdesc, x)
 			if err != nil {
 				return fmt.Errorf("index %d: %v", i, err)
 			}
@@ -419,7 +419,7 @@ func setField(msg protoreflect.Message, fdesc protoreflect.FieldDescriptor, valu
 		mutMap := msg.Mutable(fdesc).Map()
 		var k starlark.Value
 		for iter.Next(&k) {
-			kproto, err := toProto(fdesc.MapKey(), k)
+			kproto, err := toProto(thread, fdesc.MapKey(), k)
 			if err != nil {
 				return fmt.Errorf("in key of map field %s: %w", fdesc.Name(), err)
 			}
@@ -428,12 +428,12 @@ func setField(msg protoreflect.Message, fdesc protoreflect.FieldDescriptor, valu
 			// iterator guarantees the presence of some value (even if it is
 			// starlark.None). Mismatching values will be caught in toProto
 			// below.
-			v, _, err := mapping.Get(k)
+			v, _, err := mapping.Get(thread, k)
 			if err != nil {
 				return fmt.Errorf("in map field %s, at key %s: %w", fdesc.Name(), k.String(), err)
 			}
 
-			vproto, err := toProto(fdesc.MapValue(), v)
+			vproto, err := toProto(thread, fdesc.MapValue(), v)
 			if err != nil {
 				return fmt.Errorf("in map field %s, at key %s: %w", fdesc.Name(), k.String(), err)
 			}
@@ -444,7 +444,7 @@ func setField(msg protoreflect.Message, fdesc protoreflect.FieldDescriptor, valu
 		return nil
 	}
 
-	v, err := toProto(fdesc, value)
+	v, err := toProto(thread, fdesc, value)
 	if err != nil {
 		return fmt.Errorf("in field %s: %v", fdesc.Name(), err)
 	}
@@ -467,7 +467,7 @@ func setField(msg protoreflect.Message, fdesc protoreflect.FieldDescriptor, valu
 }
 
 // toProto converts a Starlark value for a message field into protoreflect form.
-func toProto(fdesc protoreflect.FieldDescriptor, v starlark.Value) (protoreflect.Value, error) {
+func toProto(thread *starlark.Thread, fdesc protoreflect.FieldDescriptor, v starlark.Value) (protoreflect.Value, error) {
 	switch fdesc.Kind() {
 	case protoreflect.BoolKind:
 		// To avoid mistakes, we require v be exactly a bool.
@@ -564,7 +564,7 @@ func toProto(fdesc protoreflect.FieldDescriptor, v starlark.Value) (protoreflect
 
 		case *starlark.Dict:
 			dest := newMessage(desc)
-			err := setFields(dest, v.Items())
+			err := setFields(thread, dest, v.Items())
 			return protoreflect.ValueOfMessage(dest), err
 		}
 
@@ -742,7 +742,7 @@ func (m *Message) Hash() (h uint32, err error) { return uint32(uintptr(unsafe.Po
 
 // Attr returns the value of this message's field of the specified name.
 // Extension fields are not accessible this way as their names are not unique.
-func (m *Message) Attr(name string) (starlark.Value, error) {
+func (m *Message) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	// The name 'descriptor' is already effectively reserved
 	// by the Go API for generated message types.
 	if name == "descriptor" {
@@ -826,7 +826,7 @@ func fieldDesc(desc protoreflect.MessageDescriptor, name string) (protoreflect.F
 
 // SetField updates a non-extension field of this message.
 // It implements the HasSetField interface.
-func (m *Message) SetField(name string, v starlark.Value) error {
+func (m *Message) SetField(thread *starlark.Thread, name string, v starlark.Value) error {
 	fdesc, err := fieldDesc(m.desc(), name)
 	if err != nil {
 		return err
@@ -835,7 +835,7 @@ func (m *Message) SetField(name string, v starlark.Value) error {
 		return fmt.Errorf("cannot set .%s field of frozen %s message",
 			name, m.desc().FullName())
 	}
-	return setField(m.msg, fdesc, v)
+	return setField(thread, m.msg, fdesc, v)
 }
 
 // AttrNames returns the set of field names defined for this message.
@@ -901,14 +901,14 @@ func (rf *RepeatedField) Type() string {
 	return fmt.Sprintf("proto.repeated<%s>", typeString(rf.typ))
 }
 
-func (rf *RepeatedField) SetIndex(i int, v starlark.Value) error {
+func (rf *RepeatedField) SetIndex(thread *starlark.Thread, i int, v starlark.Value) error {
 	if *rf.frozen {
 		return fmt.Errorf("cannot insert value in frozen repeated field")
 	}
 	if rf.itercount > 0 {
 		return fmt.Errorf("cannot insert value in repeated field with active iterators")
 	}
-	x, err := toProto(rf.typ, v)
+	x, err := toProto(thread, rf.typ, v)
 	if err != nil {
 		// The repeated field value cannot know which field it
 		// belongs to---it might be shared by several of the
@@ -994,7 +994,7 @@ func (f FileDescriptor) Type() string                { return "proto.FileDescrip
 func (f FileDescriptor) Truth() starlark.Bool        { return true }
 func (f FileDescriptor) Freeze()                     {} // immutable
 func (f FileDescriptor) Hash() (h uint32, err error) { return starlark.String(f.Desc.Path()).Hash() }
-func (f FileDescriptor) Attr(name string) (starlark.Value, error) {
+func (f FileDescriptor) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	if desc := f.Desc.Messages().ByName(protoreflect.Name(name)); desc != nil {
 		return MessageDescriptor{Desc: desc}, nil
 	}
@@ -1050,7 +1050,7 @@ func (d MessageDescriptor) Freeze()              {} // immutable
 func (d MessageDescriptor) Hash() (h uint32, err error) {
 	return starlark.String(d.Desc.FullName()).Hash()
 }
-func (d MessageDescriptor) Attr(name string) (starlark.Value, error) {
+func (d MessageDescriptor) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	if desc := d.Desc.Messages().ByName(protoreflect.Name(name)); desc != nil {
 		return MessageDescriptor{desc}, nil
 	}
@@ -1106,7 +1106,7 @@ func (d FieldDescriptor) Freeze()              {} // immutable
 func (d FieldDescriptor) Hash() (h uint32, err error) {
 	return starlark.String(d.Desc.FullName()).Hash()
 }
-func (d FieldDescriptor) Attr(name string) (starlark.Value, error) {
+func (d FieldDescriptor) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	// TODO(adonovan): expose metadata fields of Desc?
 	return nil, nil
 }
@@ -1144,7 +1144,7 @@ func (e EnumDescriptor) Type() string                { return "proto.EnumDescrip
 func (e EnumDescriptor) Truth() starlark.Bool        { return true }
 func (e EnumDescriptor) Freeze()                     {}                // immutable
 func (e EnumDescriptor) Hash() (h uint32, err error) { return 0, nil } // TODO(adonovan): number?
-func (e EnumDescriptor) Attr(name string) (starlark.Value, error) {
+func (e EnumDescriptor) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	if v := e.Desc.Values().ByName(protoreflect.Name(name)); v != nil {
 		return EnumValueDescriptor{v}, nil
 	}
@@ -1240,7 +1240,7 @@ func (e EnumValueDescriptor) Hash() (h uint32, err error) { return uint32(e.Desc
 func (e EnumValueDescriptor) AttrNames() []string {
 	return []string{"index", "name", "number", "type"}
 }
-func (e EnumValueDescriptor) Attr(name string) (starlark.Value, error) {
+func (e EnumValueDescriptor) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	switch name {
 	case "index":
 		return starlark.MakeInt(e.Desc.Index()), nil
@@ -1254,7 +1254,8 @@ func (e EnumValueDescriptor) Attr(name string) (starlark.Value, error) {
 	}
 	return nil, nil
 }
-func (x EnumValueDescriptor) CompareSameType(op syntax.Token, y_ starlark.Value, depth int) (bool, error) {
+
+func (x EnumValueDescriptor) CompareSameType(thread *starlark.Thread, op syntax.Token, y_ starlark.Value, depth int) (bool, error) {
 	y := y_.(EnumValueDescriptor)
 	switch op {
 	case syntax.EQL:
diff --git lib/time/time.go lib/time/time.go
index 7dbcf36..e1fe8a7 100644
--- lib/time/time.go
+++ lib/time/time.go
@@ -209,7 +209,7 @@ func (d Duration) Truth() starlark.Bool { return d != 0 }
 
 // Attr gets a value for a string attribute, implementing dot expression support
 // in starklark. required by starlark.HasAttrs interface.
-func (d Duration) Attr(name string) (starlark.Value, error) {
+func (d Duration) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	switch name {
 	case "hours":
 		return starlark.Float(time.Duration(d).Hours()), nil
@@ -262,7 +262,7 @@ func (d Duration) Cmp(v starlark.Value, depth int) (int, error) {
 //	duration / float = duration
 //	duration // duration = int
 //	duration * int = duration
-func (d Duration) Binary(op syntax.Token, y starlark.Value, side starlark.Side) (starlark.Value, error) {
+func (d Duration) Binary(thread *starlark.Thread, op syntax.Token, y starlark.Value, side starlark.Side) (starlark.Value, error) {
 	x := time.Duration(d)
 
 	switch op {
@@ -384,7 +384,7 @@ func (t Time) Truth() starlark.Bool { return !starlark.Bool(time.Time(t).IsZero(
 
 // Attr gets a value for a string attribute, implementing dot expression support
 // in starklark. required by starlark.HasAttrs interface.
-func (t Time) Attr(name string) (starlark.Value, error) {
+func (t Time) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	switch name {
 	case "year":
 		return starlark.MakeInt(time.Time(t).Year()), nil
@@ -443,7 +443,7 @@ func (t Time) Cmp(yV starlark.Value, depth int) (int, error) {
 //	time + duration = time
 //	time - duration = time
 //	time - time = duration
-func (t Time) Binary(op syntax.Token, y starlark.Value, side starlark.Side) (starlark.Value, error) {
+func (t Time) Binary(thread *starlark.Thread, op syntax.Token, y starlark.Value, side starlark.Side) (starlark.Value, error) {
 	x := time.Time(t)
 
 	switch op {
diff --git starlark/bench_test.go starlark/bench_test.go
index 4ff0789..092d2d3 100644
--- starlark/bench_test.go
+++ starlark/bench_test.go
@@ -82,7 +82,7 @@ func (benchmark) Type() string          { return "benchmark" }
 func (benchmark) String() string        { return "<benchmark>" }
 func (benchmark) Hash() (uint32, error) { return 0, fmt.Errorf("unhashable: benchmark") }
 func (benchmark) AttrNames() []string   { return []string{"n", "restart", "start", "stop"} }
-func (b benchmark) Attr(name string) (starlark.Value, error) {
+func (b benchmark) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	switch name {
 	case "n":
 		return starlark.MakeInt(b.b.N), nil
diff --git starlark/eval.go starlark/eval.go
index a4640e4..0681e01 100644
--- starlark/eval.go
+++ starlark/eval.go
@@ -633,14 +633,14 @@ func listExtend(x *List, y Iterable) {
 }
 
 // getAttr implements x.dot.
-func getAttr(x Value, name string) (Value, error) {
+func getAttr(thread *Thread, x Value, name string) (Value, error) {
 	hasAttr, ok := x.(HasAttrs)
 	if !ok {
 		return nil, fmt.Errorf("%s has no .%s field or method", x.Type(), name)
 	}
 
 	var errmsg string
-	v, err := hasAttr.Attr(name)
+	v, err := hasAttr.Attr(thread, name)
 	if err == nil {
 		if v != nil {
 			return v, nil // success
@@ -662,9 +662,9 @@ func getAttr(x Value, name string) (Value, error) {
 }
 
 // setField implements x.name = y.
-func setField(x Value, name string, y Value) error {
+func setField(thread *Thread, x Value, name string, y Value) error {
 	if x, ok := x.(HasSetField); ok {
-		err := x.SetField(name, y)
+		err := x.SetField(thread, name, y)
 		if _, ok := err.(NoSuchAttrError); ok {
 			// No such field: check spelling.
 			if n := spell.Nearest(name, x.AttrNames()); n != "" {
@@ -678,10 +678,10 @@ func setField(x Value, name string, y Value) error {
 }
 
 // getIndex implements x[y].
-func getIndex(x, y Value) (Value, error) {
+func getIndex(thread *Thread, x, y Value) (Value, error) {
 	switch x := x.(type) {
 	case Mapping: // dict
-		z, found, err := x.Get(y)
+		z, found, err := x.Get(thread, y)
 		if err != nil {
 			return nil, err
 		}
@@ -717,10 +717,10 @@ func outOfRange(i, n int, x Value) error {
 }
 
 // setIndex implements x[y] = z.
-func setIndex(x, y, z Value) error {
+func setIndex(thread *Thread, x, y, z Value) error {
 	switch x := x.(type) {
 	case HasSetKey:
-		if err := x.SetKey(y, z); err != nil {
+		if err := x.SetKey(thread, y, z); err != nil {
 			return err
 		}
 
@@ -737,7 +737,7 @@ func setIndex(x, y, z Value) error {
 		if i < 0 || i >= n {
 			return outOfRange(origI, n, x)
 		}
-		return x.SetIndex(i, z)
+		return x.SetIndex(thread, i, z)
 
 	default:
 		return fmt.Errorf("%s value does not support item assignment", x.Type())
@@ -766,7 +766,7 @@ func Unary(op syntax.Token, x Value) (Value, error) {
 
 // Binary applies a strict binary operator (not AND or OR) to its operands.
 // For equality tests or ordered comparisons, use Compare instead.
-func Binary(op syntax.Token, x, y Value) (Value, error) {
+func Binary(thread *Thread, op syntax.Token, x, y Value) (Value, error) {
 	switch op {
 	case syntax.PLUS:
 		switch x := x.(type) {
@@ -840,7 +840,7 @@ func Binary(op syntax.Token, x, y Value) (Value, error) {
 			if y, ok := y.(*Set); ok {
 				iter := y.Iterate()
 				defer iter.Done()
-				return x.Difference(iter)
+				return x.Difference(thread, iter)
 			}
 		}
 
@@ -1020,11 +1020,11 @@ func Binary(op syntax.Token, x, y Value) (Value, error) {
 				return x.Mod(yf), nil
 			}
 		case String:
-			return interpolate(string(x), y)
+			return interpolate(thread, string(x), y)
 		}
 
 	case syntax.NOT_IN:
-		z, err := Binary(syntax.IN, x, y)
+		z, err := Binary(thread, syntax.IN, x, y)
 		if err != nil {
 			return nil, err
 		}
@@ -1034,7 +1034,7 @@ func Binary(op syntax.Token, x, y Value) (Value, error) {
 		switch y := y.(type) {
 		case *List:
 			for _, elem := range y.elems {
-				if eq, err := Equal(elem, x); err != nil {
+				if eq, err := Equal(thread, elem, x); err != nil {
 					return nil, err
 				} else if eq {
 					return True, nil
@@ -1043,7 +1043,7 @@ func Binary(op syntax.Token, x, y Value) (Value, error) {
 			return False, nil
 		case Tuple:
 			for _, elem := range y {
-				if eq, err := Equal(elem, x); err != nil {
+				if eq, err := Equal(thread, elem, x); err != nil {
 					return nil, err
 				} else if eq {
 					return True, nil
@@ -1053,10 +1053,10 @@ func Binary(op syntax.Token, x, y Value) (Value, error) {
 		case Mapping: // e.g. dict
 			// Ignore error from Get as we cannot distinguish true
 			// errors (value cycle, type error) from "key not found".
-			_, found, _ := y.Get(x)
+			_, found, _ := y.Get(thread, x)
 			return Bool(found), nil
 		case *Set:
-			ok, err := y.Has(x)
+			ok, err := y.Has(thread, x)
 			return Bool(ok), err
 		case String:
 			needle, ok := x.(String)
@@ -1094,14 +1094,14 @@ func Binary(op syntax.Token, x, y Value) (Value, error) {
 
 		case *Dict: // union
 			if y, ok := y.(*Dict); ok {
-				return x.Union(y), nil
+				return x.Union(thread, y), nil
 			}
 
 		case *Set: // union
 			if y, ok := y.(*Set); ok {
 				iter := Iterate(y)
 				defer iter.Done()
-				return x.Union(iter)
+				return x.Union(thread, iter)
 			}
 		}
 
@@ -1115,7 +1115,7 @@ func Binary(op syntax.Token, x, y Value) (Value, error) {
 			if y, ok := y.(*Set); ok {
 				iter := y.Iterate()
 				defer iter.Done()
-				return x.Intersection(iter)
+				return x.Intersection(thread, iter)
 			}
 		}
 
@@ -1129,7 +1129,7 @@ func Binary(op syntax.Token, x, y Value) (Value, error) {
 			if y, ok := y.(*Set); ok {
 				iter := y.Iterate()
 				defer iter.Done()
-				return x.SymmetricDifference(iter)
+				return x.SymmetricDifference(thread, iter)
 			}
 		}
 
@@ -1160,13 +1160,13 @@ func Binary(op syntax.Token, x, y Value) (Value, error) {
 	// user-defined types
 	// (nil, nil) => unhandled
 	if x, ok := x.(HasBinary); ok {
-		z, err := x.Binary(op, y, Left)
+		z, err := x.Binary(thread, op, y, Left)
 		if z != nil || err != nil {
 			return z, err
 		}
 	}
 	if y, ok := y.(HasBinary); ok {
-		z, err := y.Binary(op, x, Right)
+		z, err := y.Binary(thread, op, x, Right)
 		if z != nil || err != nil {
 			return z, err
 		}
@@ -1412,7 +1412,7 @@ func asIndex(v Value, len int, result *int) error {
 
 // setArgs sets the values of the formal parameters of function fn in
 // based on the actual parameter values in args and kwargs.
-func setArgs(locals []Value, fn *Function, args Tuple, kwargs []Tuple) error {
+func setArgs(thread *Thread, locals []Value, fn *Function, args Tuple, kwargs []Tuple) error {
 
 	// This is the general schema of a function:
 	//
@@ -1504,7 +1504,7 @@ func setArgs(locals []Value, fn *Function, args Tuple, kwargs []Tuple) error {
 			return fmt.Errorf("function %s got an unexpected keyword argument %s", fn.Name(), k)
 		}
 		oldlen := kwdict.Len()
-		kwdict.SetKey(k, v)
+		kwdict.SetKey(thread, k, v)
 		if kwdict.Len() == oldlen {
 			return fmt.Errorf("function %s got multiple values for parameter %s", fn.Name(), k)
 		}
@@ -1546,7 +1546,7 @@ func setArgs(locals []Value, fn *Function, args Tuple, kwargs []Tuple) error {
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#string-interpolation
-func interpolate(format string, x Value) (Value, error) {
+func interpolate(thread *Thread, format string, x Value) (Value, error) {
 	buf := new(strings.Builder)
 	index := 0
 	nargs := 1
@@ -1579,7 +1579,7 @@ func interpolate(format string, x Value) (Value, error) {
 			key := format[:j]
 			if dict, ok := x.(Mapping); !ok {
 				return nil, fmt.Errorf("format requires a mapping")
-			} else if v, found, _ := dict.Get(String(key)); found {
+			} else if v, found, _ := dict.Get(thread, String(key)); found {
 				arg = v
 			} else {
 				return nil, fmt.Errorf("key not found: %s", key)
diff --git starlark/eval_test.go starlark/eval_test.go
index 8cb6568..efae9eb 100644
--- starlark/eval_test.go
+++ starlark/eval_test.go
@@ -250,9 +250,11 @@ func (hf *hasfields) Freeze() {
 	}
 }
 
-func (hf *hasfields) Attr(name string) (starlark.Value, error) { return hf.attrs[name], nil }
+func (hf *hasfields) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
+	return hf.attrs[name], nil
+}
 
-func (hf *hasfields) SetField(name string, val starlark.Value) error {
+func (hf *hasfields) SetField(thread *starlark.Thread, name string, val starlark.Value) error {
 	if hf.frozen {
 		return fmt.Errorf("cannot set field on a frozen hasfields")
 	}
@@ -272,7 +274,7 @@ func (hf *hasfields) AttrNames() []string {
 	return names
 }
 
-func (hf *hasfields) Binary(op syntax.Token, y starlark.Value, side starlark.Side) (starlark.Value, error) {
+func (hf *hasfields) Binary(thread *starlark.Thread, op syntax.Token, y starlark.Value, side starlark.Side) (starlark.Value, error) {
 	// This method exists so we can exercise 'list += x'
 	// where x is not Iterable but defines list+x.
 	if op == syntax.PLUS {
@@ -644,7 +646,7 @@ func TestRepeatedExec(t *testing.T) {
 		thread := new(starlark.Thread)
 		if globals, err := prog.Init(thread, predeclared); err != nil {
 			t.Errorf("x=%v: %v", test.x, err) // exec error
-		} else if eq, err := starlark.Equal(globals["y"], test.want); err != nil {
+		} else if eq, err := starlark.Equal(thread, globals["y"], test.want); err != nil {
 			t.Errorf("x=%v: %v", test.x, err) // comparison error
 		} else if !eq {
 			t.Errorf("x=%v: got y=%v, want %v", test.x, globals["y"], test.want)
@@ -1075,11 +1077,11 @@ func TestDebugFrame(t *testing.T) {
 				if val == nil {
 					continue
 				}
-				dict.SetKey(starlark.String(bind.Name), val) // ignore error
+				dict.SetKey(thread, starlark.String(bind.Name), val) // ignore error
 			}
 			for i := 0; i < fn.NumFreeVars(); i++ {
 				bind, val := fn.FreeVar(i)
-				dict.SetKey(starlark.String(bind.Name), val) // ignore error
+				dict.SetKey(thread, starlark.String(bind.Name), val) // ignore error
 			}
 			dict.Freeze()
 			return dict, nil
diff --git starlark/hashtable.go starlark/hashtable.go
index e1bbeaa..b96d29e 100644
--- starlark/hashtable.go
+++ starlark/hashtable.go
@@ -74,7 +74,7 @@ func (ht *hashtable) freeze() {
 	}
 }
 
-func (ht *hashtable) insert(k, v Value) error {
+func (ht *hashtable) insert(thread *Thread, k, v Value) error {
 	if err := ht.checkMutable("insert into"); err != nil {
 		return err
 	}
@@ -104,7 +104,7 @@ retry:
 				}
 				continue
 			}
-			if eq, err := Equal(k, e.key); err != nil {
+			if eq, err := Equal(thread, k, e.key); err != nil {
 				return err // e.g. excessively recursive tuple
 			} else if !eq {
 				continue
@@ -123,7 +123,7 @@ retry:
 
 	// Does the number of elements exceed the buckets' load factor?
 	if overloaded(int(ht.len), len(ht.table)) {
-		ht.grow()
+		ht.grow(thread)
 		goto retry
 	}
 
@@ -154,7 +154,7 @@ func overloaded(elems, buckets int) bool {
 	return elems >= bucketSize && float64(elems) >= loadFactor*float64(buckets)
 }
 
-func (ht *hashtable) grow() {
+func (ht *hashtable) grow(thread *Thread) {
 	// Double the number of buckets and rehash.
 	//
 	// Even though this makes reentrant calls to ht.insert,
@@ -168,12 +168,12 @@ func (ht *hashtable) grow() {
 	ht.tailLink = &ht.head
 	ht.len = 0
 	for e := oldhead; e != nil; e = e.next {
-		ht.insert(e.key, e.value)
+		ht.insert(thread, e.key, e.value)
 	}
 	ht.bucket0[0] = bucket{} // clear out unused initial bucket
 }
 
-func (ht *hashtable) lookup(k Value) (v Value, found bool, err error) {
+func (ht *hashtable) lookup(thread *Thread, k Value) (v Value, found bool, err error) {
 	h, err := k.Hash()
 	if err != nil {
 		return nil, false, err // unhashable
@@ -190,7 +190,7 @@ func (ht *hashtable) lookup(k Value) (v Value, found bool, err error) {
 		for i := range p.entries {
 			e := &p.entries[i]
 			if e.hash == h {
-				if eq, err := Equal(k, e.key); err != nil {
+				if eq, err := Equal(thread, k, e.key); err != nil {
 					return nil, false, err // e.g. excessively recursive tuple
 				} else if eq {
 					return e.value, true, nil // found
@@ -202,7 +202,7 @@ func (ht *hashtable) lookup(k Value) (v Value, found bool, err error) {
 }
 
 // count returns the number of distinct elements of iter that are elements of ht.
-func (ht *hashtable) count(iter Iterator) (int, error) {
+func (ht *hashtable) count(thread *Thread, iter Iterator) (int, error) {
 	if ht.table == nil {
 		return 0, nil // empty
 	}
@@ -234,7 +234,7 @@ func (ht *hashtable) count(iter Iterator) (int, error) {
 			for j := range p.entries {
 				e := &p.entries[j]
 				if e.hash == h {
-					if eq, err := Equal(k, e.key); err != nil {
+					if eq, err := Equal(thread, k, e.key); err != nil {
 						return 0, err
 					} else if eq {
 						bitIndex := i<<3 + j
@@ -281,7 +281,7 @@ func (ht *hashtable) keys() []Value {
 	return keys
 }
 
-func (ht *hashtable) delete(k Value) (v Value, found bool, err error) {
+func (ht *hashtable) delete(thread *Thread, k Value) (v Value, found bool, err error) {
 	if err := ht.checkMutable("delete from"); err != nil {
 		return nil, false, err
 	}
@@ -301,7 +301,7 @@ func (ht *hashtable) delete(k Value) (v Value, found bool, err error) {
 		for i := range p.entries {
 			e := &p.entries[i]
 			if e.hash == h {
-				if eq, err := Equal(k, e.key); err != nil {
+				if eq, err := Equal(thread, k, e.key); err != nil {
 					return nil, false, err
 				} else if eq {
 					// Remove e from doubly-linked list.
@@ -353,9 +353,9 @@ func (ht *hashtable) clear() error {
 	return nil
 }
 
-func (ht *hashtable) addAll(other *hashtable) error {
+func (ht *hashtable) addAll(thread *Thread, other *hashtable) error {
 	for e := other.head; e != nil; e = e.next {
-		if err := ht.insert(e.key, e.value); err != nil {
+		if err := ht.insert(thread, e.key, e.value); err != nil {
 			return err
 		}
 	}
diff --git starlark/hashtable_test.go starlark/hashtable_test.go
index bcbc8e8..881b0f5 100644
--- starlark/hashtable_test.go
+++ starlark/hashtable_test.go
@@ -71,12 +71,13 @@ func testHashtable(tb testing.TB, sane map[int]bool) {
 	var i int // index into testInts
 
 	var ht hashtable
+	thread := new(Thread)
 
 	// Insert 10000 random ints into the map.
 	for j := 0; j < testIters; j++ {
 		k := testInts[i]
 		i++
-		if err := ht.insert(k.Int, None); err != nil {
+		if err := ht.insert(thread, k.Int, None); err != nil {
 			tb.Fatal(err)
 		}
 		if sane != nil {
@@ -88,7 +89,7 @@ func testHashtable(tb testing.TB, sane map[int]bool) {
 	for j := 0; j < testIters; j++ {
 		k := testInts[i]
 		i++
-		_, found, err := ht.lookup(k.Int)
+		_, found, err := ht.lookup(thread, k.Int)
 		if err != nil {
 			tb.Fatal(err)
 		}
@@ -104,7 +105,7 @@ func testHashtable(tb testing.TB, sane map[int]bool) {
 	for j := 0; j < testIters; j++ {
 		k := testInts[i]
 		i++
-		_, found, err := ht.delete(k.Int)
+		_, found, err := ht.delete(thread, k.Int)
 		if err != nil {
 			tb.Fatal(err)
 		}
@@ -127,11 +128,12 @@ func testHashtable(tb testing.TB, sane map[int]bool) {
 func TestHashtableCount(t *testing.T) {
 	const count = 1000
 	ht := new(hashtable)
+	thread := new(Thread)
 	for i := 0; i < count; i++ {
-		ht.insert(MakeInt(i), None)
+		ht.insert(thread, MakeInt(i), None)
 	}
 
-	if c, err := ht.count(rangeValue{0, count, 1, count}.Iterate()); err != nil {
+	if c, err := ht.count(thread, rangeValue{0, count, 1, count}.Iterate()); err != nil {
 		t.Error(err)
 	} else if c != count {
 		t.Errorf("count doesn't match: expected %d got %d", count, c)
diff --git starlark/interp.go starlark/interp.go
index 261077f..3243d32 100644
--- starlark/interp.go
+++ starlark/interp.go
@@ -55,7 +55,7 @@ func (fn *Function) CallInternal(thread *Thread, args Tuple, kwargs []Tuple) (Va
 	stack := space[nlocals:]          // operand stack
 
 	// Digest arguments and set parameters.
-	err := setArgs(locals, fn, args, kwargs)
+	err := setArgs(thread, locals, fn, args, kwargs)
 	if err != nil {
 		return nil, thread.evalError(err)
 	}
@@ -156,7 +156,7 @@ loop:
 			y := stack[sp-1]
 			x := stack[sp-2]
 			sp -= 2
-			ok, err2 := Compare(op, x, y)
+			ok, err2 := Compare(thread, op, x, y)
 			if err2 != nil {
 				err = err2
 				break loop
@@ -183,7 +183,7 @@ loop:
 			y := stack[sp-1]
 			x := stack[sp-2]
 			sp -= 2
-			z, err2 := Binary(binop, x, y)
+			z, err2 := Binary(thread, binop, x, y)
 			if err2 != nil {
 				err = err2
 				break loop
@@ -225,7 +225,7 @@ loop:
 				}
 			}
 			if z == nil {
-				z, err = Binary(syntax.PLUS, x, y)
+				z, err = Binary(thread, syntax.PLUS, x, y)
 				if err != nil {
 					break loop
 				}
@@ -248,12 +248,12 @@ loop:
 					if err = xdict.ht.checkMutable("apply |= to"); err != nil {
 						break loop
 					}
-					xdict.ht.addAll(&ydict.ht) // can't fail
+					xdict.ht.addAll(thread, &ydict.ht) // can't fail
 					z = xdict
 				}
 			}
 			if z == nil {
-				z, err = Binary(syntax.PIPE, x, y)
+				z, err = Binary(thread, syntax.PIPE, x, y)
 				if err != nil {
 					break loop
 				}
@@ -410,7 +410,7 @@ loop:
 			y := stack[sp-2]
 			x := stack[sp-3]
 			sp -= 3
-			err = setIndex(x, y, z)
+			err = setIndex(thread, x, y, z)
 			if err != nil {
 				break loop
 			}
@@ -419,7 +419,7 @@ loop:
 			y := stack[sp-1]
 			x := stack[sp-2]
 			sp -= 2
-			z, err2 := getIndex(x, y)
+			z, err2 := getIndex(thread, x, y)
 			if err2 != nil {
 				err = err2
 				break loop
@@ -430,7 +430,7 @@ loop:
 		case compile.ATTR:
 			x := stack[sp-1]
 			name := f.Prog.Names[arg]
-			y, err2 := getAttr(x, name)
+			y, err2 := getAttr(thread, x, name)
 			if err2 != nil {
 				err = err2
 				break loop
@@ -442,7 +442,7 @@ loop:
 			x := stack[sp-2]
 			sp -= 2
 			name := f.Prog.Names[arg]
-			if err2 := setField(x, name, y); err2 != nil {
+			if err2 := setField(thread, x, name, y); err2 != nil {
 				err = err2
 				break loop
 			}
@@ -457,7 +457,7 @@ loop:
 			v := stack[sp-1]
 			sp -= 3
 			oldlen := dict.Len()
-			if err2 := dict.SetKey(k, v); err2 != nil {
+			if err2 := dict.SetKey(thread, k, v); err2 != nil {
 				err = err2
 				break loop
 			}
diff --git starlark/iter.go starlark/iter.go
index 5436d9f..a270546 100644
--- starlark/iter.go
+++ starlark/iter.go
@@ -90,7 +90,7 @@ func Elements(iterable Iterable) iter.Seq[Value] {
 // Push iterators are provided as a convenience for Go client code. The
 // core iteration behavior of Starlark for-loops is defined by the
 // [Iterable] interface.
-func Entries(mapping IterableMapping) iter.Seq2[Value, Value] {
+func Entries(thread *Thread, mapping IterableMapping) iter.Seq2[Value, Value] {
 	// If available (e.g. *Dict), use specialized push iterator,
 	// as it gets k and v in one shot.
 	type hasEntries interface {
@@ -105,7 +105,7 @@ func Entries(mapping IterableMapping) iter.Seq2[Value, Value] {
 		defer iter.Done()
 		var k Value
 		for iter.Next(&k) {
-			v, found, err := mapping.Get(k)
+			v, found, err := mapping.Get(thread, k)
 			if err != nil || !found {
 				panic(fmt.Sprintf("Iterate and Get are inconsistent (mapping=%v, key=%v)",
 					mapping.Type(), k.Type()))
diff --git starlark/iterator_test.go starlark/iterator_test.go
index c910496..aa6ff9d 100644
--- starlark/iterator_test.go
+++ starlark/iterator_test.go
@@ -67,9 +67,10 @@ func TestListElements(t *testing.T) {
 
 func TestSetElements(t *testing.T) {
 	set := NewSet(3)
-	set.Insert(MakeInt(1))
-	set.Insert(MakeInt(2))
-	set.Insert(MakeInt(3))
+	thread := new(Thread)
+	set.Insert(thread, MakeInt(1))
+	set.Insert(thread, MakeInt(2))
+	set.Insert(thread, MakeInt(3))
 
 	var got []string
 	for elem := range set.Elements() {
@@ -92,9 +93,10 @@ func TestSetElements(t *testing.T) {
 
 func TestDictEntries(t *testing.T) {
 	dict := NewDict(2)
-	dict.SetKey(String("one"), MakeInt(1))
-	dict.SetKey(String("two"), MakeInt(2))
-	dict.SetKey(String("three"), MakeInt(3))
+	thread := new(Thread)
+	dict.SetKey(thread, String("one"), MakeInt(1))
+	dict.SetKey(thread, String("two"), MakeInt(2))
+	dict.SetKey(thread, String("three"), MakeInt(3))
 
 	var got []string
 	for k, v := range dict.Entries() {
@@ -103,7 +105,7 @@ func TestDictEntries(t *testing.T) {
 			break // skip 3
 		}
 	}
-	for k, v := range Entries(dict) {
+	for k, v := range Entries(thread, dict) {
 		got = append(got, fmt.Sprintf("%v %v", k, v))
 		if len(got) == 4 {
 			break // skip 3
diff --git starlark/library.go starlark/library.go
index 6d7ff45..f03d552 100644
--- starlark/library.go
+++ starlark/library.go
@@ -302,7 +302,7 @@ func dict(thread *Thread, _ *Builtin, args Tuple, kwargs []Tuple) (Value, error)
 		return nil, fmt.Errorf("dict: got %d arguments, want at most 1", len(args))
 	}
 	dict := new(Dict)
-	if err := updateDict(dict, args, kwargs); err != nil {
+	if err := updateDict(thread, dict, args, kwargs); err != nil {
 		return nil, fmt.Errorf("dict: %v", err)
 	}
 	return dict, nil
@@ -459,7 +459,7 @@ func getattr(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, err
 		return nil, err
 	}
 	if object, ok := object.(HasAttrs); ok {
-		v, err := object.Attr(name)
+		v, err := object.Attr(thread, name)
 		if err != nil {
 			// An error could mean the field doesn't exist,
 			// or it exists but could not be computed.
@@ -487,7 +487,7 @@ func hasattr(thread *Thread, _ *Builtin, args Tuple, kwargs []Tuple) (Value, err
 		return nil, err
 	}
 	if object, ok := object.(HasAttrs); ok {
-		v, err := object.Attr(name)
+		v, err := object.Attr(thread, name)
 		if err == nil {
 			return Bool(v != nil), nil
 		}
@@ -755,7 +755,7 @@ func minmax(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, erro
 			key = res
 		}
 
-		if ok, err := Compare(op, key, extremeKey); err != nil {
+		if ok, err := Compare(thread, op, key, extremeKey); err != nil {
 			return nil, nameErr(b, err)
 		} else if ok {
 			extremum = x
@@ -904,7 +904,7 @@ func (r rangeValue) Type() string          { return "range" }
 func (r rangeValue) Truth() Bool           { return r.len > 0 }
 func (r rangeValue) Hash() (uint32, error) { return 0, fmt.Errorf("unhashable: range") }
 
-func (x rangeValue) CompareSameType(op syntax.Token, y_ Value, depth int) (bool, error) {
+func (x rangeValue) CompareSameType(thread *Thread, op syntax.Token, y_ Value, depth int) (bool, error) {
 	y := y_.(rangeValue)
 	switch op {
 	case syntax.EQL:
@@ -999,7 +999,7 @@ func set(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error)
 		defer iter.Done()
 		var x Value
 		for iter.Next(&x) {
-			if err := set.Insert(x); err != nil {
+			if err := set.Insert(thread, x); err != nil {
 				return nil, nameErr(b, err)
 			}
 		}
@@ -1045,7 +1045,7 @@ func sorted(thread *Thread, _ *Builtin, args Tuple, kwargs []Tuple) (Value, erro
 		}
 	}
 
-	slice := &sortSlice{keys: keys, values: values}
+	slice := &sortSlice{thread: thread, keys: keys, values: values}
 	if reverse {
 		sort.Stable(sort.Reverse(slice))
 	} else {
@@ -1055,6 +1055,7 @@ func sorted(thread *Thread, _ *Builtin, args Tuple, kwargs []Tuple) (Value, erro
 }
 
 type sortSlice struct {
+	thread *Thread
 	keys   []Value // nil => values[i] is key
 	values []Value
 	err    error
@@ -1066,7 +1067,7 @@ func (s *sortSlice) Less(i, j int) bool {
 	if s.keys == nil {
 		keys = s.values
 	}
-	ok, err := Compare(syntax.LT, keys[i], keys[j])
+	ok, err := Compare(s.thread, syntax.LT, keys[i], keys[j])
 	if err != nil {
 		s.err = err
 	}
@@ -1202,12 +1203,12 @@ func zip(thread *Thread, _ *Builtin, args Tuple, kwargs []Tuple) (Value, error)
 // ---- methods of built-in types ---
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#dict·get
-func dict_get(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func dict_get(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var key, dflt Value
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 1, &key, &dflt); err != nil {
 		return nil, err
 	}
-	if v, ok, err := b.Receiver().(*Dict).Get(key); err != nil {
+	if v, ok, err := b.Receiver().(*Dict).Get(thread, key); err != nil {
 		return nil, nameErr(b, err)
 	} else if ok {
 		return v, nil
@@ -1247,12 +1248,12 @@ func dict_keys(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error)
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#dict·pop
-func dict_pop(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func dict_pop(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var k, d Value
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 1, &k, &d); err != nil {
 		return nil, err
 	}
-	if v, found, err := b.Receiver().(*Dict).Delete(k); err != nil {
+	if v, found, err := b.Receiver().(*Dict).Delete(thread, k); err != nil {
 		return nil, nameErr(b, err) // dict is frozen or key is unhashable
 	} else if found {
 		return v, nil
@@ -1263,7 +1264,7 @@ func dict_pop(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error)
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#dict·popitem
-func dict_popitem(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func dict_popitem(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 0); err != nil {
 		return nil, err
 	}
@@ -1272,7 +1273,7 @@ func dict_popitem(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, err
 	if !ok {
 		return nil, nameErr(b, "empty dict")
 	}
-	v, _, err := recv.Delete(k)
+	v, _, err := recv.Delete(thread, k)
 	if err != nil {
 		return nil, nameErr(b, err) // dict is frozen
 	}
@@ -1280,17 +1281,17 @@ func dict_popitem(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, err
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#dict·setdefault
-func dict_setdefault(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func dict_setdefault(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var key, dflt Value = nil, None
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 1, &key, &dflt); err != nil {
 		return nil, err
 	}
 	dict := b.Receiver().(*Dict)
-	if v, ok, err := dict.Get(key); err != nil {
+	if v, ok, err := dict.Get(thread, key); err != nil {
 		return nil, nameErr(b, err)
 	} else if ok {
 		return v, nil
-	} else if err := dict.SetKey(key, dflt); err != nil {
+	} else if err := dict.SetKey(thread, key, dflt); err != nil {
 		return nil, nameErr(b, err)
 	} else {
 		return dflt, nil
@@ -1298,11 +1299,11 @@ func dict_setdefault(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value,
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#dict·update
-func dict_update(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func dict_update(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	if len(args) > 1 {
 		return nil, fmt.Errorf("update: got %d arguments, want at most 1", len(args))
 	}
-	if err := updateDict(b.Receiver().(*Dict), args, kwargs); err != nil {
+	if err := updateDict(thread, b.Receiver().(*Dict), args, kwargs); err != nil {
 		return nil, fmt.Errorf("update: %v", err)
 	}
 	return None, nil
@@ -1361,7 +1362,7 @@ func list_extend(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, erro
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#list·index
-func list_index(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func list_index(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var value, start_, end_ Value
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 1, &value, &start_, &end_); err != nil {
 		return nil, err
@@ -1374,7 +1375,7 @@ func list_index(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error
 	}
 
 	for i := start; i < end; i++ {
-		if eq, err := Equal(recv.elems[i], value); err != nil {
+		if eq, err := Equal(thread, recv.elems[i], value); err != nil {
 			return nil, nameErr(b, err)
 		} else if eq {
 			return MakeInt(i), nil
@@ -1414,7 +1415,7 @@ func list_insert(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, erro
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#list·remove
-func list_remove(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func list_remove(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	recv := b.Receiver().(*List)
 	var value Value
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 1, &value); err != nil {
@@ -1424,7 +1425,7 @@ func list_remove(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, erro
 		return nil, nameErr(b, err)
 	}
 	for i, elem := range recv.elems {
-		if eq, err := Equal(elem, value); err != nil {
+		if eq, err := Equal(thread, elem, value); err != nil {
 			return nil, fmt.Errorf("remove: %v", err)
 		} else if eq {
 			recv.elems = append(recv.elems[:i], recv.elems[i+1:]...)
@@ -2180,17 +2181,17 @@ func string_splitlines(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set·add.
-func set_add(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func set_add(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var elem Value
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 1, &elem); err != nil {
 		return nil, err
 	}
-	if found, err := b.Receiver().(*Set).Has(elem); err != nil {
+	if found, err := b.Receiver().(*Set).Has(thread, elem); err != nil {
 		return nil, nameErr(b, err)
 	} else if found {
 		return None, nil
 	}
-	err := b.Receiver().(*Set).Insert(elem)
+	err := b.Receiver().(*Set).Insert(thread, elem)
 	if err != nil {
 		return nil, nameErr(b, err)
 	}
@@ -2211,7 +2212,7 @@ func set_clear(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error)
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set·difference.
-func set_difference(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func set_difference(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	// TODO: support multiple others: s.difference(*others)
 	var other Iterable
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 0, &other); err != nil {
@@ -2219,7 +2220,7 @@ func set_difference(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, e
 	}
 	iter := other.Iterate()
 	defer iter.Done()
-	diff, err := b.Receiver().(*Set).Difference(iter)
+	diff, err := b.Receiver().(*Set).Difference(thread, iter)
 	if err != nil {
 		return nil, nameErr(b, err)
 	}
@@ -2227,7 +2228,7 @@ func set_difference(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, e
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set_intersection.
-func set_intersection(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func set_intersection(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	// TODO: support multiple others: s.difference(*others)
 	var other Iterable
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 0, &other); err != nil {
@@ -2235,7 +2236,7 @@ func set_intersection(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value,
 	}
 	iter := other.Iterate()
 	defer iter.Done()
-	diff, err := b.Receiver().(*Set).Intersection(iter)
+	diff, err := b.Receiver().(*Set).Intersection(thread, iter)
 	if err != nil {
 		return nil, nameErr(b, err)
 	}
@@ -2243,14 +2244,14 @@ func set_intersection(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value,
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set_issubset.
-func set_issubset(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func set_issubset(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var other Iterable
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 0, &other); err != nil {
 		return nil, err
 	}
 	iter := other.Iterate()
 	defer iter.Done()
-	diff, err := b.Receiver().(*Set).IsSubset(iter)
+	diff, err := b.Receiver().(*Set).IsSubset(thread, iter)
 	if err != nil {
 		return nil, nameErr(b, err)
 	}
@@ -2258,14 +2259,14 @@ func set_issubset(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, err
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set_issuperset.
-func set_issuperset(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func set_issuperset(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var other Iterable
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 0, &other); err != nil {
 		return nil, err
 	}
 	iter := other.Iterate()
 	defer iter.Done()
-	diff, err := b.Receiver().(*Set).IsSuperset(iter)
+	diff, err := b.Receiver().(*Set).IsSuperset(thread, iter)
 	if err != nil {
 		return nil, nameErr(b, err)
 	}
@@ -2273,24 +2274,24 @@ func set_issuperset(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, e
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set·discard.
-func set_discard(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func set_discard(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var k Value
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 1, &k); err != nil {
 		return nil, err
 	}
-	if found, err := b.Receiver().(*Set).Has(k); err != nil {
+	if found, err := b.Receiver().(*Set).Has(thread, k); err != nil {
 		return nil, nameErr(b, err)
 	} else if !found {
 		return None, nil
 	}
-	if _, err := b.Receiver().(*Set).Delete(k); err != nil {
+	if _, err := b.Receiver().(*Set).Delete(thread, k); err != nil {
 		return nil, nameErr(b, err) // set is frozen
 	}
 	return None, nil
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set·pop.
-func set_pop(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func set_pop(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 0); err != nil {
 		return nil, err
 	}
@@ -2299,7 +2300,7 @@ func set_pop(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	if !ok {
 		return nil, nameErr(b, "empty set")
 	}
-	_, err := recv.Delete(k)
+	_, err := recv.Delete(thread, k)
 	if err != nil {
 		return nil, nameErr(b, err) // set is frozen
 	}
@@ -2307,12 +2308,12 @@ func set_pop(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set·remove.
-func set_remove(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func set_remove(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var k Value
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 1, &k); err != nil {
 		return nil, err
 	}
-	if found, err := b.Receiver().(*Set).Delete(k); err != nil {
+	if found, err := b.Receiver().(*Set).Delete(thread, k); err != nil {
 		return nil, nameErr(b, err) // dict is frozen or key is unhashable
 	} else if found {
 		return None, nil
@@ -2321,14 +2322,14 @@ func set_remove(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set·symmetric_difference.
-func set_symmetric_difference(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+func set_symmetric_difference(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
 	var other Iterable
 	if err := UnpackPositionalArgs(b.Name(), args, kwargs, 0, &other); err != nil {
 		return nil, err
 	}
 	iter := other.Iterate()
 	defer iter.Done()
-	diff, err := b.Receiver().(*Set).SymmetricDifference(iter)
+	diff, err := b.Receiver().(*Set).SymmetricDifference(thread, iter)
 	if err != nil {
 		return nil, nameErr(b, err)
 	}
@@ -2336,17 +2337,17 @@ func set_symmetric_difference(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple)
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set·union.
-func set_union(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
-	receiverSet := b.Receiver().(*Set).clone()
-	if err := setUpdate(receiverSet, args, kwargs); err != nil {
+func set_union(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+	receiverSet := b.Receiver().(*Set).clone(thread)
+	if err := setUpdate(thread, receiverSet, args, kwargs); err != nil {
 		return nil, nameErr(b, err)
 	}
 	return receiverSet, nil
 }
 
 // https://github.com/google/starlark-go/blob/master/doc/spec.md#set·update.
-func set_update(_ *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
-	if err := setUpdate(b.Receiver().(*Set), args, kwargs); err != nil {
+func set_update(thread *Thread, b *Builtin, args Tuple, kwargs []Tuple) (Value, error) {
+	if err := setUpdate(thread, b.Receiver().(*Set), args, kwargs); err != nil {
 		return nil, nameErr(b, err)
 	}
 	return None, nil
@@ -2387,13 +2388,13 @@ func string_find_impl(b *Builtin, args Tuple, kwargs []Tuple, allowError, last b
 
 // Common implementation of builtin dict function and dict.update method.
 // Precondition: len(updates) == 0 or 1.
-func updateDict(dict *Dict, updates Tuple, kwargs []Tuple) error {
+func updateDict(thread *Thread, dict *Dict, updates Tuple, kwargs []Tuple) error {
 	if len(updates) == 1 {
 		switch updates := updates[0].(type) {
 		case IterableMapping:
 			// Iterate over dict's key/value pairs, not just keys.
 			for _, item := range updates.Items() {
-				if err := dict.SetKey(item[0], item[1]); err != nil {
+				if err := dict.SetKey(thread, item[0], item[1]); err != nil {
 					return err // dict is frozen
 				}
 			}
@@ -2421,7 +2422,7 @@ func updateDict(dict *Dict, updates Tuple, kwargs []Tuple) error {
 				var k, v Value
 				iter2.Next(&k)
 				iter2.Next(&v)
-				if err := dict.SetKey(k, v); err != nil {
+				if err := dict.SetKey(thread, k, v); err != nil {
 					return err
 				}
 			}
@@ -2431,7 +2432,7 @@ func updateDict(dict *Dict, updates Tuple, kwargs []Tuple) error {
 	// Then add the kwargs.
 	before := dict.Len()
 	for _, pair := range kwargs {
-		if err := dict.SetKey(pair[0], pair[1]); err != nil {
+		if err := dict.SetKey(thread, pair[0], pair[1]); err != nil {
 			return err // dict is frozen
 		}
 	}
@@ -2451,7 +2452,7 @@ func updateDict(dict *Dict, updates Tuple, kwargs []Tuple) error {
 	return nil
 }
 
-func setUpdate(s *Set, args Tuple, kwargs []Tuple) error {
+func setUpdate(thread *Thread, s *Set, args Tuple, kwargs []Tuple) error {
 	if len(kwargs) > 0 {
 		return errors.New("does not accept keyword arguments")
 	}
@@ -2464,7 +2465,7 @@ func setUpdate(s *Set, args Tuple, kwargs []Tuple) error {
 		if err := func() error {
 			iter := iterable.Iterate()
 			defer iter.Done()
-			return s.InsertAll(iter)
+			return s.InsertAll(thread, iter)
 		}(); err != nil {
 			return err
 		}
diff --git starlark/value.go starlark/value.go
index d89a9f5..841b358 100644
--- starlark/value.go
+++ starlark/value.go
@@ -133,7 +133,7 @@ type Comparable interface {
 	// Client code should not call this method.  Instead, use the
 	// standalone Compare or Equals functions, which are defined for
 	// all pairs of operands.
-	CompareSameType(op syntax.Token, y Value, depth int) (bool, error)
+	CompareSameType(thread *Thread, op syntax.Token, y Value, depth int) (bool, error)
 }
 
 // A TotallyOrdered is a type whose values form a total order:
@@ -240,7 +240,7 @@ type Sliceable interface {
 // evaluator does this before the call.
 type HasSetIndex interface {
 	Indexable
-	SetIndex(index int, v Value) error
+	SetIndex(thread *Thread, index int, v Value) error
 }
 
 var (
@@ -289,7 +289,7 @@ type Mapping interface {
 	//
 	// Get also defines the behavior of "v in mapping".
 	// The 'in' operator reports the 'found' component, ignoring errors.
-	Get(Value) (v Value, found bool, err error)
+	Get(*Thread, Value) (v Value, found bool, err error)
 }
 
 // An IterableMapping is a mapping that supports key enumeration.
@@ -306,7 +306,7 @@ var _ IterableMapping = (*Dict)(nil)
 // A HasSetKey supports map update using x[k]=v syntax, like a dictionary.
 type HasSetKey interface {
 	Mapping
-	SetKey(k, v Value) error
+	SetKey(thread *Thread, k, v Value) error
 }
 
 var _ HasSetKey = (*Dict)(nil)
@@ -321,7 +321,7 @@ var _ HasSetKey = (*Dict)(nil)
 // function rather than calling the method directly.
 type HasBinary interface {
 	Value
-	Binary(op syntax.Token, y Value, side Side) (Value, error)
+	Binary(thread *Thread, op syntax.Token, y Value, side Side) (Value, error)
 }
 
 type Side bool
@@ -350,7 +350,7 @@ type HasUnary interface {
 // free to return a more precise error.
 type HasAttrs interface {
 	Value
-	Attr(name string) (Value, error) // returns (nil, nil) if attribute not present
+	Attr(thread *Thread, name string) (Value, error) // returns (nil, nil) if attribute not present
 	AttrNames() []string             // callers must not modify the result.
 }
 
@@ -368,7 +368,7 @@ var (
 // warn of possible misspelling.
 type HasSetField interface {
 	HasAttrs
-	SetField(name string, val Value) error
+	SetField(thread *Thread, name string, val Value) error
 }
 
 // A NoSuchAttrError may be returned by an implementation of
@@ -410,7 +410,7 @@ func (b Bool) Type() string          { return "bool" }
 func (b Bool) Freeze()               {} // immutable
 func (b Bool) Truth() Bool           { return b }
 func (b Bool) Hash() (uint32, error) { return uint32(b2i(bool(b))), nil }
-func (x Bool) CompareSameType(op syntax.Token, y_ Value, depth int) (bool, error) {
+func (x Bool) CompareSameType(thread *Thread, op syntax.Token, y_ Value, depth int) (bool, error) {
 	y := y_.(Bool)
 	return threeway(op, b2i(bool(x))-b2i(bool(y))), nil
 }
@@ -581,10 +581,12 @@ func (s String) Slice(start, end, step int) Value {
 	return String(str)
 }
 
-func (s String) Attr(name string) (Value, error) { return builtinAttr(s, name, stringMethods) }
+func (s String) Attr(thread *Thread, name string) (Value, error) {
+	return builtinAttr(s, name, stringMethods)
+}
 func (s String) AttrNames() []string             { return builtinAttrNames(stringMethods) }
 
-func (x String) CompareSameType(op syntax.Token, y_ Value, depth int) (bool, error) {
+func (x String) CompareSameType(thread *Thread, op syntax.Token, y_ Value, depth int) (bool, error) {
 	y := y_.(String)
 	return threeway(op, strings.Compare(string(x), string(y))), nil
 }
@@ -855,55 +857,62 @@ func NewDict(size int) *Dict {
 	return dict
 }
 
-func (d *Dict) Clear() error                                    { return d.ht.clear() }
-func (d *Dict) Delete(k Value) (v Value, found bool, err error) { return d.ht.delete(k) }
-func (d *Dict) Get(k Value) (v Value, found bool, err error)    { return d.ht.lookup(k) }
-func (d *Dict) Items() []Tuple                                  { return d.ht.items() }
-func (d *Dict) Keys() []Value                                   { return d.ht.keys() }
-func (d *Dict) Len() int                                        { return int(d.ht.len) }
-func (d *Dict) Iterate() Iterator                               { return d.ht.iterate() }
-func (d *Dict) SetKey(k, v Value) error                         { return d.ht.insert(k, v) }
-func (d *Dict) String() string                                  { return toString(d) }
-func (d *Dict) Type() string                                    { return "dict" }
-func (d *Dict) Freeze()                                         { d.ht.freeze() }
-func (d *Dict) Truth() Bool                                     { return d.Len() > 0 }
-func (d *Dict) Hash() (uint32, error)                           { return 0, fmt.Errorf("unhashable type: dict") }
-
-func (x *Dict) Union(y *Dict) *Dict {
+func (d *Dict) Clear() error { return d.ht.clear() }
+func (d *Dict) Delete(thread *Thread, k Value) (v Value, found bool, err error) {
+	return d.ht.delete(thread, k)
+}
+
+func (d *Dict) Get(thread *Thread, k Value) (v Value, found bool, err error) {
+	return d.ht.lookup(thread, k)
+}
+func (d *Dict) Items() []Tuple                          { return d.ht.items() }
+func (d *Dict) Keys() []Value                           { return d.ht.keys() }
+func (d *Dict) Len() int                                { return int(d.ht.len) }
+func (d *Dict) Iterate() Iterator                       { return d.ht.iterate() }
+func (d *Dict) SetKey(thread *Thread, k, v Value) error { return d.ht.insert(thread, k, v) }
+func (d *Dict) String() string                          { return toString(d) }
+func (d *Dict) Type() string                            { return "dict" }
+func (d *Dict) Freeze()                                 { d.ht.freeze() }
+func (d *Dict) Truth() Bool                             { return d.Len() > 0 }
+func (d *Dict) Hash() (uint32, error)                   { return 0, fmt.Errorf("unhashable type: dict") }
+
+func (x *Dict) Union(thread *Thread, y *Dict) *Dict {
 	z := new(Dict)
-	z.ht.init(x.Len()) // a lower bound
-	z.ht.addAll(&x.ht) // can't fail
-	z.ht.addAll(&y.ht) // can't fail
+	z.ht.init(x.Len())         // a lower bound
+	z.ht.addAll(thread, &x.ht) // can't fail
+	z.ht.addAll(thread, &y.ht) // can't fail
 	return z
 }
 
-func (d *Dict) Attr(name string) (Value, error) { return builtinAttr(d, name, dictMethods) }
+func (d *Dict) Attr(thread *Thread, name string) (Value, error) {
+	return builtinAttr(d, name, dictMethods)
+}
 func (d *Dict) AttrNames() []string             { return builtinAttrNames(dictMethods) }
 
-func (x *Dict) CompareSameType(op syntax.Token, y_ Value, depth int) (bool, error) {
+func (x *Dict) CompareSameType(thread *Thread, op syntax.Token, y_ Value, depth int) (bool, error) {
 	y := y_.(*Dict)
 	switch op {
 	case syntax.EQL:
-		ok, err := dictsEqual(x, y, depth)
+		ok, err := dictsEqual(thread, x, y, depth)
 		return ok, err
 	case syntax.NEQ:
-		ok, err := dictsEqual(x, y, depth)
+		ok, err := dictsEqual(thread, x, y, depth)
 		return !ok, err
 	default:
 		return false, fmt.Errorf("%s %s %s not implemented", x.Type(), op, y.Type())
 	}
 }
 
-func dictsEqual(x, y *Dict, depth int) (bool, error) {
+func dictsEqual(thread *Thread, x, y *Dict, depth int) (bool, error) {
 	if x.Len() != y.Len() {
 		return false, nil
 	}
 	for e := x.ht.head; e != nil; e = e.next {
 		key, xval := e.key, e.value
 
-		if yval, found, _ := y.Get(key); !found {
+		if yval, found, _ := y.Get(thread, key); !found {
 			return false, nil
-		} else if eq, err := EqualDepth(xval, yval, depth-1); err != nil {
+		} else if eq, err := EqualDepth(thread, xval, yval, depth-1); err != nil {
 			return false, err
 		} else if !eq {
 			return false, nil
@@ -965,7 +974,9 @@ func (l *List) Slice(start, end, step int) Value {
 	return NewList(list)
 }
 
-func (l *List) Attr(name string) (Value, error) { return builtinAttr(l, name, listMethods) }
+func (l *List) Attr(thread *Thread, name string) (Value, error) {
+	return builtinAttr(l, name, listMethods)
+}
 func (l *List) AttrNames() []string             { return builtinAttrNames(listMethods) }
 
 func (l *List) Iterate() Iterator {
@@ -975,14 +986,14 @@ func (l *List) Iterate() Iterator {
 	return &listIterator{l: l}
 }
 
-func (x *List) CompareSameType(op syntax.Token, y_ Value, depth int) (bool, error) {
+func (x *List) CompareSameType(thread *Thread, op syntax.Token, y_ Value, depth int) (bool, error) {
 	y := y_.(*List)
 	// It's tempting to check x == y as an optimization here,
 	// but wrong because a list containing NaN is not equal to itself.
-	return sliceCompare(op, x.elems, y.elems, depth)
+	return sliceCompare(thread, op, x.elems, y.elems, depth)
 }
 
-func sliceCompare(op syntax.Token, x, y []Value, depth int) (bool, error) {
+func sliceCompare(thread *Thread, op syntax.Token, x, y []Value, depth int) (bool, error) {
 	// Fast path: check length.
 	if len(x) != len(y) && (op == syntax.EQL || op == syntax.NEQ) {
 		return op == syntax.NEQ, nil
@@ -990,7 +1001,7 @@ func sliceCompare(op syntax.Token, x, y []Value, depth int) (bool, error) {
 
 	// Find first element that is not equal in both lists.
 	for i := 0; i < len(x) && i < len(y); i++ {
-		if eq, err := EqualDepth(x[i], y[i], depth-1); err != nil {
+		if eq, err := EqualDepth(thread, x[i], y[i], depth-1); err != nil {
 			return false, err
 		} else if !eq {
 			switch op {
@@ -999,7 +1010,7 @@ func sliceCompare(op syntax.Token, x, y []Value, depth int) (bool, error) {
 			case syntax.NEQ:
 				return true, nil
 			default:
-				return CompareDepth(op, x[i], y[i], depth-1)
+				return CompareDepth(thread, op, x[i], y[i], depth-1)
 			}
 		}
 	}
@@ -1027,7 +1038,7 @@ func (it *listIterator) Done() {
 	}
 }
 
-func (l *List) SetIndex(i int, v Value) error {
+func (l *List) SetIndex(thread *Thread, i int, v Value) error {
 	if err := l.checkMutable("assign to element of"); err != nil {
 		return err
 	}
@@ -1084,9 +1095,9 @@ func (t Tuple) String() string { return toString(t) }
 func (t Tuple) Type() string   { return "tuple" }
 func (t Tuple) Truth() Bool    { return len(t) > 0 }
 
-func (x Tuple) CompareSameType(op syntax.Token, y_ Value, depth int) (bool, error) {
+func (x Tuple) CompareSameType(thread *Thread, op syntax.Token, y_ Value, depth int) (bool, error) {
 	y := y_.(Tuple)
-	return sliceCompare(op, x, y, depth)
+	return sliceCompare(thread, op, x, y, depth)
 }
 
 func (t Tuple) Hash() (uint32, error) {
@@ -1132,29 +1143,37 @@ func NewSet(size int) *Set {
 	return set
 }
 
-func (s *Set) Delete(k Value) (found bool, err error) { _, found, err = s.ht.delete(k); return }
-func (s *Set) Clear() error                           { return s.ht.clear() }
-func (s *Set) Has(k Value) (found bool, err error)    { _, found, err = s.ht.lookup(k); return }
-func (s *Set) Insert(k Value) error                   { return s.ht.insert(k, None) }
-func (s *Set) Len() int                               { return int(s.ht.len) }
-func (s *Set) Iterate() Iterator                      { return s.ht.iterate() }
-func (s *Set) String() string                         { return toString(s) }
-func (s *Set) Type() string                           { return "set" }
-func (s *Set) Freeze()                                { s.ht.freeze() }
-func (s *Set) Hash() (uint32, error)                  { return 0, fmt.Errorf("unhashable type: set") }
-func (s *Set) Truth() Bool                            { return s.Len() > 0 }
+func (s *Set) Delete(thread *Thread, k Value) (found bool, err error) {
+	_, found, err = s.ht.delete(thread, k)
+	return
+}
+func (s *Set) Clear() error { return s.ht.clear() }
+func (s *Set) Has(thread *Thread, k Value) (found bool, err error) {
+	_, found, err = s.ht.lookup(thread, k)
+	return
+}
+func (s *Set) Insert(thread *Thread, k Value) error { return s.ht.insert(thread, k, None) }
+func (s *Set) Len() int                             { return int(s.ht.len) }
+func (s *Set) Iterate() Iterator                    { return s.ht.iterate() }
+func (s *Set) String() string                       { return toString(s) }
+func (s *Set) Type() string                         { return "set" }
+func (s *Set) Freeze()                              { s.ht.freeze() }
+func (s *Set) Hash() (uint32, error)                { return 0, fmt.Errorf("unhashable type: set") }
+func (s *Set) Truth() Bool                          { return s.Len() > 0 }
 
-func (s *Set) Attr(name string) (Value, error) { return builtinAttr(s, name, setMethods) }
+func (s *Set) Attr(thread *Thread, name string) (Value, error) {
+	return builtinAttr(s, name, setMethods)
+}
 func (s *Set) AttrNames() []string             { return builtinAttrNames(setMethods) }
 
-func (x *Set) CompareSameType(op syntax.Token, y_ Value, depth int) (bool, error) {
+func (x *Set) CompareSameType(thread *Thread, op syntax.Token, y_ Value, depth int) (bool, error) {
 	y := y_.(*Set)
 	switch op {
 	case syntax.EQL:
-		ok, err := setsEqual(x, y, depth)
+		ok, err := setsEqual(thread, x, y, depth)
 		return ok, err
 	case syntax.NEQ:
-		ok, err := setsEqual(x, y, depth)
+		ok, err := setsEqual(thread, x, y, depth)
 		return !ok, err
 	case syntax.GE: // superset
 		if x.Len() < y.Len() {
@@ -1162,50 +1181,50 @@ func (x *Set) CompareSameType(op syntax.Token, y_ Value, depth int) (bool, error
 		}
 		iter := y.Iterate()
 		defer iter.Done()
-		return x.IsSuperset(iter)
+		return x.IsSuperset(thread, iter)
 	case syntax.LE: // subset
 		if x.Len() > y.Len() {
 			return false, nil
 		}
 		iter := y.Iterate()
 		defer iter.Done()
-		return x.IsSubset(iter)
+		return x.IsSubset(thread, iter)
 	case syntax.GT: // proper superset
 		if x.Len() <= y.Len() {
 			return false, nil
 		}
 		iter := y.Iterate()
 		defer iter.Done()
-		return x.IsSuperset(iter)
+		return x.IsSuperset(thread, iter)
 	case syntax.LT: // proper subset
 		if x.Len() >= y.Len() {
 			return false, nil
 		}
 		iter := y.Iterate()
 		defer iter.Done()
-		return x.IsSubset(iter)
+		return x.IsSubset(thread, iter)
 	default:
 		return false, fmt.Errorf("%s %s %s not implemented", x.Type(), op, y.Type())
 	}
 }
 
-func setsEqual(x, y *Set, depth int) (bool, error) {
+func setsEqual(thread *Thread, x, y *Set, depth int) (bool, error) {
 	if x.Len() != y.Len() {
 		return false, nil
 	}
 	for e := x.ht.head; e != nil; e = e.next {
-		if found, _ := y.Has(e.key); !found {
+		if found, _ := y.Has(thread, e.key); !found {
 			return false, nil
 		}
 	}
 	return true, nil
 }
 
-func setFromIterator(iter Iterator) (*Set, error) {
+func setFromIterator(thread *Thread, iter Iterator) (*Set, error) {
 	var x Value
 	set := new(Set)
 	for iter.Next(&x) {
-		err := set.Insert(x)
+		err := set.Insert(thread, x)
 		if err != nil {
 			return set, err
 		}
@@ -1213,50 +1232,50 @@ func setFromIterator(iter Iterator) (*Set, error) {
 	return set, nil
 }
 
-func (s *Set) clone() *Set {
+func (s *Set) clone(thread *Thread) *Set {
 	set := new(Set)
 	for e := s.ht.head; e != nil; e = e.next {
-		set.Insert(e.key) // can't fail
+		set.Insert(thread, e.key) // can't fail
 	}
 	return set
 }
 
-func (s *Set) Union(iter Iterator) (Value, error) {
-	set := s.clone()
+func (s *Set) Union(thread *Thread, iter Iterator) (Value, error) {
+	set := s.clone(thread)
 	var x Value
 	for iter.Next(&x) {
-		if err := set.Insert(x); err != nil {
+		if err := set.Insert(thread, x); err != nil {
 			return nil, err
 		}
 	}
 	return set, nil
 }
 
-func (s *Set) InsertAll(iter Iterator) error {
+func (s *Set) InsertAll(thread *Thread, iter Iterator) error {
 	var x Value
 	for iter.Next(&x) {
-		if err := s.Insert(x); err != nil {
+		if err := s.Insert(thread, x); err != nil {
 			return err
 		}
 	}
 	return nil
 }
 
-func (s *Set) Difference(other Iterator) (Value, error) {
-	diff := s.clone()
+func (s *Set) Difference(thread *Thread, other Iterator) (Value, error) {
+	diff := s.clone(thread)
 	var x Value
 	for other.Next(&x) {
-		if _, err := diff.Delete(x); err != nil {
+		if _, err := diff.Delete(thread, x); err != nil {
 			return nil, err
 		}
 	}
 	return diff, nil
 }
 
-func (s *Set) IsSuperset(other Iterator) (bool, error) {
+func (s *Set) IsSuperset(thread *Thread, other Iterator) (bool, error) {
 	var x Value
 	for other.Next(&x) {
-		found, err := s.Has(x)
+		found, err := s.Has(thread, x)
 		if err != nil {
 			return false, err
 		}
@@ -1267,24 +1286,24 @@ func (s *Set) IsSuperset(other Iterator) (bool, error) {
 	return true, nil
 }
 
-func (s *Set) IsSubset(other Iterator) (bool, error) {
-	if count, err := s.ht.count(other); err != nil {
+func (s *Set) IsSubset(thread *Thread, other Iterator) (bool, error) {
+	if count, err := s.ht.count(thread, other); err != nil {
 		return false, err
 	} else {
 		return count == s.Len(), nil
 	}
 }
 
-func (s *Set) Intersection(other Iterator) (Value, error) {
+func (s *Set) Intersection(thread *Thread, other Iterator) (Value, error) {
 	intersect := new(Set)
 	var x Value
 	for other.Next(&x) {
-		found, err := s.Has(x)
+		found, err := s.Has(thread, x)
 		if err != nil {
 			return nil, err
 		}
 		if found {
-			err = intersect.Insert(x)
+			err = intersect.Insert(thread, x)
 			if err != nil {
 				return nil, err
 			}
@@ -1293,16 +1312,16 @@ func (s *Set) Intersection(other Iterator) (Value, error) {
 	return intersect, nil
 }
 
-func (s *Set) SymmetricDifference(other Iterator) (Value, error) {
-	diff := s.clone()
+func (s *Set) SymmetricDifference(thread *Thread, other Iterator) (Value, error) {
+	diff := s.clone(thread)
 	var x Value
 	for other.Next(&x) {
-		found, err := diff.Delete(x)
+		found, err := diff.Delete(thread, x)
 		if err != nil {
 			return nil, err
 		}
 		if !found {
-			diff.Insert(x)
+			diff.Insert(thread, x)
 		}
 	}
 	return diff, nil
@@ -1428,19 +1447,19 @@ func pathContains(path []Value, x Value) bool {
 var CompareLimit = 10
 
 // Equal reports whether two Starlark values are equal.
-func Equal(x, y Value) (bool, error) {
+func Equal(thread *Thread, x, y Value) (bool, error) {
 	if x, ok := x.(String); ok {
 		return x == y, nil // fast path for an important special case
 	}
-	return EqualDepth(x, y, CompareLimit)
+	return EqualDepth(thread, x, y, CompareLimit)
 }
 
 // EqualDepth reports whether two Starlark values are equal.
 //
 // Recursive comparisons by implementations of Value.CompareSameType
 // should use EqualDepth to prevent infinite recursion.
-func EqualDepth(x, y Value, depth int) (bool, error) {
-	return CompareDepth(syntax.EQL, x, y, depth)
+func EqualDepth(thread *Thread, x, y Value, depth int) (bool, error) {
+	return CompareDepth(thread, syntax.EQL, x, y, depth)
 }
 
 // Compare compares two Starlark values.
@@ -1450,8 +1469,8 @@ func EqualDepth(x, y Value, depth int) (bool, error) {
 //
 // Recursive comparisons by implementations of Value.CompareSameType
 // should use CompareDepth to prevent infinite recursion.
-func Compare(op syntax.Token, x, y Value) (bool, error) {
-	return CompareDepth(op, x, y, CompareLimit)
+func Compare(thread *Thread, op syntax.Token, x, y Value) (bool, error) {
+	return CompareDepth(thread, op, x, y, CompareLimit)
 }
 
 // CompareDepth compares two Starlark values.
@@ -1461,13 +1480,13 @@ func Compare(op syntax.Token, x, y Value) (bool, error) {
 //
 // The depth parameter limits the maximum depth of recursion
 // in cyclic data structures.
-func CompareDepth(op syntax.Token, x, y Value, depth int) (bool, error) {
+func CompareDepth(thread *Thread, op syntax.Token, x, y Value, depth int) (bool, error) {
 	if depth < 1 {
 		return false, fmt.Errorf("comparison exceeded maximum recursion depth")
 	}
 	if sameType(x, y) {
 		if xcomp, ok := x.(Comparable); ok {
-			return xcomp.CompareSameType(op, y, depth)
+			return xcomp.CompareSameType(thread, op, y, depth)
 		}
 
 		if xcomp, ok := x.(TotallyOrdered); ok {
@@ -1623,7 +1642,9 @@ func (b Bytes) Hash() (uint32, error) { return String(b).Hash() }
 func (b Bytes) Len() int              { return len(b) }
 func (b Bytes) Index(i int) Value     { return b[i : i+1] }
 
-func (b Bytes) Attr(name string) (Value, error) { return builtinAttr(b, name, bytesMethods) }
+func (b Bytes) Attr(thread *Thread, name string) (Value, error) {
+	return builtinAttr(b, name, bytesMethods)
+}
 func (b Bytes) AttrNames() []string             { return builtinAttrNames(bytesMethods) }
 
 func (b Bytes) Slice(start, end, step int) Value {
@@ -1639,7 +1660,7 @@ func (b Bytes) Slice(start, end, step int) Value {
 	return Bytes(str)
 }
 
-func (x Bytes) CompareSameType(op syntax.Token, y_ Value, depth int) (bool, error) {
+func (x Bytes) CompareSameType(thread *Thread, op syntax.Token, y_ Value, depth int) (bool, error) {
 	y := y_.(Bytes)
 	return threeway(op, strings.Compare(string(x), string(y))), nil
 }
diff --git starlarkstruct/module.go starlarkstruct/module.go
index 735c98a..e85ea5f 100644
--- starlarkstruct/module.go
+++ starlarkstruct/module.go
@@ -18,7 +18,9 @@ type Module struct {
 
 var _ starlark.HasAttrs = (*Module)(nil)
 
-func (m *Module) Attr(name string) (starlark.Value, error) { return m.Members[name], nil }
+func (m *Module) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
+	return m.Members[name], nil
+}
 func (m *Module) AttrNames() []string                      { return m.Members.Keys() }
 func (m *Module) Freeze()                                  { m.Members.Freeze() }
 func (m *Module) Hash() (uint32, error)                    { return 0, fmt.Errorf("unhashable: %s", m.Type()) }
diff --git starlarkstruct/struct.go starlarkstruct/struct.go
index 44612d2..7649d76 100644
--- starlarkstruct/struct.go
+++ starlarkstruct/struct.go
@@ -181,13 +181,13 @@ func (s *Struct) Freeze() {
 	}
 }
 
-func (x *Struct) Binary(op syntax.Token, y starlark.Value, side starlark.Side) (starlark.Value, error) {
+func (x *Struct) Binary(thread *starlark.Thread, op syntax.Token, y starlark.Value, side starlark.Side) (starlark.Value, error) {
 	if y, ok := y.(*Struct); ok && op == syntax.PLUS {
 		if side == starlark.Right {
 			x, y = y, x
 		}
 
-		if eq, err := starlark.Equal(x.constructor, y.constructor); err != nil {
+		if eq, err := starlark.Equal(thread, x.constructor, y.constructor); err != nil {
 			return nil, fmt.Errorf("in %s + %s: error comparing constructors: %v",
 				x.constructor, y.constructor, err)
 		} else if !eq {
@@ -209,7 +209,7 @@ func (x *Struct) Binary(op syntax.Token, y starlark.Value, side starlark.Side) (
 }
 
 // Attr returns the value of the specified field.
-func (s *Struct) Attr(name string) (starlark.Value, error) {
+func (s *Struct) Attr(thread *starlark.Thread, name string) (starlark.Value, error) {
 	// Binary search the entries.
 	// This implementation is a specialization of
 	// sort.Search that avoids dynamic dispatch.
@@ -246,25 +246,25 @@ func (s *Struct) AttrNames() []string {
 	return names
 }
 
-func (x *Struct) CompareSameType(op syntax.Token, y_ starlark.Value, depth int) (bool, error) {
+func (x *Struct) CompareSameType(thread *starlark.Thread, op syntax.Token, y_ starlark.Value, depth int) (bool, error) {
 	y := y_.(*Struct)
 	switch op {
 	case syntax.EQL:
-		return structsEqual(x, y, depth)
+		return structsEqual(thread, x, y, depth)
 	case syntax.NEQ:
-		eq, err := structsEqual(x, y, depth)
+		eq, err := structsEqual(thread, x, y, depth)
 		return !eq, err
 	default:
 		return false, fmt.Errorf("%s %s %s not implemented", x.Type(), op, y.Type())
 	}
 }
 
-func structsEqual(x, y *Struct, depth int) (bool, error) {
+func structsEqual(thread *starlark.Thread, x, y *Struct, depth int) (bool, error) {
 	if x.len() != y.len() {
 		return false, nil
 	}
 
-	if eq, err := starlark.Equal(x.constructor, y.constructor); err != nil {
+	if eq, err := starlark.Equal(thread, x.constructor, y.constructor); err != nil {
 		return false, fmt.Errorf("error comparing struct constructors %v and %v: %v",
 			x.constructor, y.constructor, err)
 	} else if !eq {
@@ -274,7 +274,7 @@ func structsEqual(x, y *Struct, depth int) (bool, error) {
 	for i, n := 0, x.len(); i < n; i++ {
 		if x.entries[i].name != y.entries[i].name {
 			return false, nil
-		} else if eq, err := starlark.EqualDepth(x.entries[i].value, y.entries[i].value, depth-1); err != nil {
+		} else if eq, err := starlark.EqualDepth(thread, x.entries[i].value, y.entries[i].value, depth-1); err != nil {
 			return false, err
 		} else if !eq {
 			return false, nil
